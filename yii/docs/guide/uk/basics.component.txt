Компонент
=========
Yii-додатки складаються з компонентів-об'єктів, створених згідно зі специфікаціями.
Компонент (component) — це екземпляр класу [CComponent] або похідного від нього.
Використання компонента в основному включає доступ до його властивостей, а також виклик і обробку його подій. 
Базовий клас [CComponent] встановлює те, як визначаються властивості й події.

Властивість компонента
-------------------
Властивість компонента схожа на публічну змінну-член класу (public member variable). 
Ми можемо читати або встановлювати його значення. Наприклад:

~~~
[php]
$width=$component->textWidth; // одержуєм значення властивості textWidth
$component->enableCaching=true; // встановлюєм значення властивості enableCaching
~~~

Для того, щоб створити властивість компонента необхідно просто оголосити публічну змінну в класі компонента.
Більш гнучкий варіант — визначити зчитуючі (getter) і записуючі (setter), наприклад:

~~~
[php]
public function getTextWidth()
{
    return $this->_textWidth;
}

public function setTextWidth($value)
{
    $this->_textWidth=$value;
}
~~~

У наведеному коді визначена властивість `textWidth` (ім'я нечутливе до регістру), доступна  для запису.

При читанні викликається метод читання `geTtextWidth()`, що повертає значення властивості. 
Відповідно, при записі буде викликаний метод запису `setTextWidth()`. 
Якщо метод запису не визначений, властивість буде доступно тільки для читання, а
при спробі запису буде викликане виключення. Використання методів читання й 
запису має додаткову перевагу: при читанні або записі значення 
властивості, можуть бути виконані додаткові дії (такі як перевірка на коректність, 
виклик події й ін.).

>Note|замітка: Є невелика різниця у визначенні властивості через методи й через просте
оголошення змінної. У першому випадку ім'я властивості нечутливо до регістру, 
у другому — чутливо.


Події компонента
------------------
Події компонента — це спеціальні властивості, у якості значень яких виступають
спеціальні методи (обробник подій). Прикріплення методу до події приведе до того, що метод буде викликаний 
автоматично при виникненні події. Тому поведінка компонента може бути 
задана зовсім відмінною від тієї, що закладується при розробці.

Подія компонента задається шляхом створення методу з іменем, що починаються на `on`. 
Подібно іменам властивостей, заданих через методи читання й запису, імена подій 
не чутливі до регістру. Наступний код задає подію `onClicked`:

~~~
[php]
public function onClicked($event)
{
	$this->raisEevent('onClicked', $event);
}
~~~

де `$event` — це екземпляр класу [CEvent] або похідного від нього,
події, що представляє параметр. До події можна підключити обробник, як показано нижче:

~~~
[php]
$component->onClicked=$callback;
~~~

де `$callback` — це коректний callback-виклик PHP (див.
Php-Функцію call_user_func). Це може бути або глобальна функція, або метод класу.
В останньому випадку виклику повинен передаватись масив: `array($object,'methodName')`.

Обробник події повинен бути визначений у такий спосіб:

~~~
[php]
function methodName($event)
{
    …
}
~~~

де `$event` — це параметр, що описує подю ( походить із виклику `raiseEvent()`).
Параметр `$event` — це екземпляр класу [Cevent] або його похідного.
Як мінімум, він містить інформацію про те, хто викликав подію.

Починаючи з версії 1.0.10 обробник події може бути анонімною функцією,
(потребує наявності версії PHP 5.3+). Наприклад,

~~~
[php]
$component->onClicked=function($event) {
	…
}
~~~

Якщо тепер викликати `onClicked()`, подію `onClicked` буде викликано (всередині `onClicked()`), і прикріплений обробник 
події буде запущений автоматично.

До події може бути прикріплене кілька обробників. 
При виникненні події обробники будуть викликані в тому порядку,
у якому вони були прикріплені до події. 
Якщо всередині обробника необхідно запобігти виклику наступних обробників, 
необхідно встановити [$event->handled|cevent::handled] в `true`.


Поведінка компонента
------------------

Починаючи з версії 1.0.2, до компонента була додана підтримка [домішок (mixin)](http://ru.wikipedia.org/wiki/Mixin)
і тепер до компонента можна прикріпити одну або кілька поведінок. *Поведінка* — це об'єкт, чиї методи можуть бути «успадковані»
компонентом, до якого прикріплені, за допомогою об'єднання функціонала замість чіткої спеціалізації ( як у випадку звичайного спадкування класу).
До компонента можна прикріпитикулька поведінок і в такий спосіб одержати множинне спадкування.

Поведінка класів повинна реалізовувати інтерфейс [IBehavior]. Більшість поведінок можуть бути створені шляхом розширення 
базового класу [CBehavior]. У випадку, якщо поведінку необхідно прикріпити до [моделі](/doc/guide/basics.model), її можна 
створити на основі класу [CModelBehavior] або класу [CActiveRecordBehavior], який реалізує додаткові, 
специфічні для моделі можливості.

Щоб скористатися поведінкою, її необхідно прикріпити до компонента шляхом виклику методу 
[attach()|IBehavior::attach]. Далі ми викликаємо метод поведінки через компонент:

~~~
[php]
// $name унікально ідентифікує поведінки в компоненті
$component->attachBehavior($name,$behavior);
// test() є методом $behavior
$component->test();
~~~

До прикріпленої поведінки можна звертатися, як до звичайної властивості компонента.
Наприклад, якщо поведінка з іменем `tree` прикріплена до компонента, ми можемо одержати 
посилання на цей об'єкт поведінки в такий спосіб:

~~~
[php]
$behavior=$component->tree;
// еквівалентно виразу:
// $behavior=$component->asa('tree');
~~~

Поведінку можна тимчасово деактивувати таким чином, щоб її методи були недоступні через компонент.
Наприклад:

~~~
[php]
$component->disableBehavior($name);
// вираз нижче приведе до виклику виключення
$component->test();
$component->enableBehavior($name);
// тут все буде працювати нормально
$component->test();
~~~

У випадку, коли дві поведінки, прикріплені до одного компоненту, мають методи з однаковими іменами,
перевага буде мати метод поведінки, яка була прикріплене першою.

Використання поведінок разом з [подіями](#component-event) дає додаткові можливості.
Поведінка, прикріплена до компонента, може привласнювати деякі свої методи подіям компонента.
В цьому випадку, поведінка одержує можливість стежити або міняти нормальний хід виконання компонента.

Починаючи з версії 1.1.0, властивості поведінки також можуть бути доступні з
компонента, до якого вона прив'язана. Властивості містять у собі як відкриті, так і
визначені через геттери/ сеттери поведінки.
Наприклад, поведінка має властивість із іменем `xyz` і прив'язана до компонента
`$a'. Тоді ми можемо використовувати вираз `$a->xyz` для доступу до властивості.

<div class="revision">$Id: basics.component.txt 1474 2009-10-18 21:13:52Z qiang.xue $</div>

