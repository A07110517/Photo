Контролер
==========
`Контролер (controller)` — це екземпляр класу [CController] або похідного від нього.
Контролер створюється додатком у випадку, коли користувач робить відповідний запрос. 
При запуску контролер виконує відповідні дії, що звичайно 
має на увазі створення відповідних моделей і рендеринг необхідних відображеннь(view в MVC термынології).
У найпростішому випадку `дія` — це метод класу контролера, назва
якого починається на `action`.

У контролера є дія по замовчанню, яка виконується, коли користувач не вказує дію при запиті.
За замовчуванням ця дія називається `index`. Змінити її можна шляхом установки 
значення [CController::defaultAction].

Нижче наведений мінімальний код класу контролера. Оскільки цей контролер не
визначає жодної дії, звертання до нього приведе до виклику виключення.

~~~
[php]
class SiteController extends CController
{
}
~~~


Маршрут
-------
Контролери й дії визначаються по їх ідентифікаторах.
Ідентифікатор контролера — це запис формату `path/to/xyz`, що відповідає
файлу класу контролера `protected/controllers/path/to/XyzController.php`, де `xyz` 
слід замінити реальною назвою класу (наприклад, `post` відповідає 
`protected/controllers/PostController.php`). Ідентифікатор дії — це назва
методу без префікса `action`. Наприклад, якщо клас контролера містить метод 
`actionEdit`, те ідентифікатор відповідної дії — `edit`.

> Note|замітка: До версії 1.0.3 ідентифікатор контролера вказувався як 
`path.to.xyz` замість `path/to/xyz`.

Користувач звертається до контролера й дії за допомогою маршруту (route). 
Маршрут формується шляхом об'єднання ідентифікаторів контролера й дії,
відділених символом `/`. Наприклад, маршрут `post/edit` вказує на дію 
`edit` контролера `PostController` і, за замовчуванням, URL `http://hostname/index.php?r=post/edit` 
приведе до виклику саме цих контролера й дії. 

> Note|замітка: За замовчуванням маршрути чутливі до регістру.
>Починаючи з версії 1.0.1 це можливо змінити шляхом встановлення властивості 
>[CUrlManager::caseSensitive у конфігурації додатка] рівною false. 
>У режимі нечутливому до регістру переконайтеся, що назви директорій, 
>утримуючих файли класів контролерів написані в нижньому регістрі, а також 
>що [controller map|CWebApplication::controllerMap] і [action map|CController::actions] 
>використовують ключі в нижньому регістрі.


Створення екземпляра контролера
-------------------------------
Екземпляр контролера створюється, коли [CWebApplication] оброблює вхідний запит.
Одержавши ідентифікатор контролера, додаток використовує наступні правила для 
визначення класу контролера і його місця розташування:

- якщо встановлена властивість [CWebApplication::catchallRequest], контролер буде визначений цією властивістю, а контролер, запрошений користувачем, буде проігноровано. 
Як правило, це використовується для встановлення додатка в режим технічного обслуговування 
і відображення статичної сторінки з відповідним повідомленням;

- якщо ідентифікатор контролера виявлений в [CWebApplication::controllerMap], то для 
створення екземпляра контролера  буде використана відповідна конфігурація контролера;

- якщо ідентифікатор контролера відповідає формату `'path/to/xyz'`, те ім'я класу 
контролера визначається як `XyzController`, а відповідний клас як
`protected/controllers/path/to/XyzController.php`. 
Наприклад, ідентифікатор контролера `admin/user` буде розпізнаний як клас
контролера — `Usercontroller` і файл класу —
`protected/controllers/admin/UserController.php`. Якщо файл класу не існує,
буде викликане виключення [CHttpException] з кодом помилки 404.

У випадку використання [модулів](/doc/guide/basics.module) (доступні, починаючи з
версії 1.0.3), процес описаний вище буде виглядати трохи інакше. Зокрема,
додаток перевірить, чи ідентифікатор відповідає контролеру всередині модуля.
У випадку, якщо це має місце, буде створений екземпляр модуля разом з екземпляром
контролера.


Дія
--------
Як було згадано вище, дія — це метод, ім'я якого починається на `action`.
Ще один спосіб — створити клас дії й указати контролеру створювати
екземпляр цього класу при необхідності. Такий підхід дозволяє використовувати
дії повторно.


Для створення класу дії необхідно виконати наступне:

~~~
[php]
class UpdateAction extends CAction
{
	public function run()
	{
		// деяка логіка дії
	}
}
~~~

Щоб контролер знав про цю дію, необхідно перевизначити метод
[actions()|CController::actions] у класі контролера:

~~~
[php]
class PostController extends CController
{
	public function actions()
	{
		return array(
			'edit'=>'application.controllers.post.UpdateAction',
		);
	}
}
~~~

У наведеному коді ми використовуємо псевдонім маршруту `application.controllers.post.UpdateAction` 
Щоб вказати на файл класу дії `protected/controllers/post/UpdateAction.php`.
Створюючи дії, засновані на класах, можна організувати додаток у модульному стилі. 
Наприклад структура, директорій, приведена нижче, може бути використана для розташування коду контролерів:
~~~
protected/
    controllers/
        PostController.php
        UserController.php
        post/
            CreateAction.php
            ReadAction.php
            UpdateAction.php
        user/
            CreateAction.php
            ListAction.php
            ProfileAction.php
            UpdateAction.php
~~~


Фільтри
---------------
Фільтр (filter) – це частина коду, що може виконуватися до або після
виконання дії контролера залежно від конфігурації. Наприклад, фільтр
контролю доступу може перевіряти,чи аутентифікований користувач перед тим,
як буде виконана запитана дія. Фільтр, що контролює продуктивність додатку,
може бути використаний для визначення часу, витраченого на виконання дії.

Дія може мати безліч фільтрів. Фільтри запускаються в в такому порядку, як
 вони зазначені в списку фільтрів, при цьому фільтр може запобігти виконанню
дії і наступних за ним фільтрів.

Фільтр може бути визначений як метод класу контролера. Ім'я методу повинне починатися на `filter`. 
Наприклад, існування методу `filterAccessControl` означає, що визначений фільтр `accessControl`. 
Метод фільтра оформляється в такий спосіб:

~~~
[php]
public function filterAccessControl($filterchain)
{
	// для виконання наступних фільтрів і виконання дії викличте метод $filterchain->run()
}
~~~

де `$filterChain` — екземпляр класу [CFilterChain] список, що представляє собою
фільтри, асоційовані із запитаною дією. У коді фільтра можна викликати
`$filterChain->run()` для того, щоб продовжити виконання наступних фільтрів і дії.

Фільтр також може бути екземпляром класу [CFilter] або похідного від нього. 
Наступний код визначає новий клас фільтра:

~~~
[php]
class PerformanceFilter extends CFilter
{
	protected function preFilter($filterChain)
	{
		// код, виконуваний до виконання дії
		return true; // false — для випадку, коли дія не повинна бути виконана
	}

	protected function postFilter($filterChain)
	{
		// код, виконуваний після виконання дії
	}
}
~~~

Для того, щоб застосувати фільтр до дії, необхідно перевизначити метод 
`CController::filters()`  масив, що повертає, конфігурацій фільтрів. Наприклад:

~~~
[php]
class PostController extends CController
{
	…
	public function filters()
	{
		return array(
			'postOnly + edit, create',
			array(
				'application.filters.PerformanceFilter - edit, create',
				'unit'=>'second',
			),
		);
	}
}
~~~

Даний код визначає два фільтри: `postOnly` і `PerformanceFilter`.
Фільтр `postonly` заданий як метод (відповідний метод уже визначений в 
[CController]), в той час як `PerformanceFilter` — фільтр на базі класу.
Псевдонім `application.filters.PerformanceFilter` вказує на файл класу фільтра —
`protected/filters/PerformanceFilter`. Для конфігурації `PerformanceFilter`
використаний масив, тому можливо ініціалізувати значення властивості фільтра.
У цьому випадку властивість `unit` фільтра `PerformanceFilter` буде 
ініціалізовано значенням `'second'`.

Використовуючи оператори `'+'` і `'-'` можна вказати, до яких дій повинен чи
не повинен бути застосованим фільтр. У наведеному прикладі `postOnly` повинен бути
застосований до дій `edit` і `create`, а `PerformanceFilter` — до всіх дій,
* крім* `edit` і `create`. Якщо оператори `'+'` і `'-'` не зазначені, фільтр буде
застосований до всіх дій.

<div class="revision">$Id: basics.controller.txt 1263 2009-07-21 19:22:00Z qiang.xue $</div>